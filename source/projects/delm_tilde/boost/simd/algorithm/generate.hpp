//==================================================================================================
/*!
  @file

  @copyright 2017 NumScale SAS

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
**/
//==================================================================================================
#ifndef BOOST_SIMD_ALGORITHM_GENERATE_HPP_INCLUDED
#define BOOST_SIMD_ALGORITHM_GENERATE_HPP_INCLUDED

#include <boost/simd/range/segmented_output_range.hpp>
#include <boost/simd/as.hpp>
#include <boost/simd/pack.hpp>

namespace boost { namespace simd
{
  /*!
    @ingroup group-std

    Assigns each element in range [first, last) a value generated by
    the successive calls to the given function object g.

    @param first  Beginning of the range of elements
    @param last   End of the range of elements
    @param g      unary function object to generate elements

    @par Requirement

      - @c first, @c last and @c out must be pointer to Vectorizable type.

      - @c g must be a polymorphic unary function object, i.e callable on generic types.
         its prototype must be T g(as_<T>) as g can be called for scalars and packs and
         must have a way to choose its return type.

    @warningbox{The g prototype is not the one of the stdlibc++ algorithm.}

    @par Example:

      @snippet generate.cpp generate

    @par Possible output:

      @snippet generate.txt generate

  **/
  template<typename T, typename Gen>
  void generate(T * first, T * last, Gen g)
  {
    auto pr = segmented_output_range(first,last);

    // prologue
    auto r0 = std::get<0>(pr);
    std::generate(r0.begin(), r0.end(), [&g](){return g(as_<T>()); });
    // main SIMD part
    auto r1 = std::get<1>(pr);
    std::generate(r1.begin(), r1.end(), [&g](){return g(as_<pack<T>>()); });
    // epilogue
    auto r2 = std::get<2>(pr);
    std::generate(r2.begin(), r2.end(), [&g](){return g(as_<T>()); });
  }

} }

#endif
